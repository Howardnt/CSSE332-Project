Project Milestone 3
Author(s): Jack Traversa, Atli Arnarsson, Noah Howard
Date: 5/19/25

High level description
======================
In the kernel, we have added a syscall that creates a new process. This process will start
executing the function pointer given to it after it has copied the page tables from its parent
process. The user must supply some memory to be used as the stack for the new thread.

At the user level, we have created a fairly minimal wrapper around the new syscall to make
creating threads easier. It can pass in a void* argument to the function and the threads’
information is saved to an instance of the sthread_t type so that it can be used later.

More of an internal feature, but processes have a linked list of all their “peers” processes
which share an address space.

We also have a syscall that joins a thread, once it has been created. The user must call this thread_combine function, which waits until the thread has finished. The user must free the stack manually.
================
Describe the decisions you have made for thread create, including answers to
the questions above.

M2: We decided to take arguments as a void* which can be cast to another type if needed, but we decided not to have the call return anything (for now). To answer some of the questions from the instructions: the address where the stack starts is put into the sp register of the new process, and epc is the register that determines where the thread will start executing after creation. The argument passed in is put in a0.
M3: We added the stack as an argument passed in, it should be at least 4096 bytes of memory that the parent assures the child is theirs and will not be messed with as long as they are alive. We also have shared memory now.

Memory sharing
===============
We created our own version of uvmcopy called copy_mappings. Instead of allocating new memory for the page tables, it maps to the existing physical addresses of the parent process. Additionally, kalloc, kfree, and copy_mappings reference count in order to prevent early freeing and double freeing.

Test cases
===========
Test Case 3 creates a variable number of threads, which prints out their pid and their arguments (which should be their thread number, according to the parent), and then joins all of the threads.
Test Case 4 has a variable stored in memory which multiple threads modify and the final result is printed, indicating that all of the threads have proper access to that place in memory.
Additional comments
==================
We decided to switch from a kernel stack assignment to having the user do it themselves. We thought it would simplify the implementation.
Grade
======
We believe that we should receive an A. We have spent quite a long time (10+ hours) working on this milestone and we have also gone to Office Hours to understand better the problems we were facing. As far as we are aware, our implementation works as requested.

